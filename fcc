#!/usr/bin/env bash
set -euo pipefail

# fcc: Forty-two Compiler Collection driver (Containerized Version)

# Pipeline (default): docker run clang -E -std=c89 -> docker run cc1 -> docker run llc -> docker run as -> docker run clang (link)
# Fallback (if --use-cc1-pp): docker run cc1 internal preprocessor -> docker run cc1 -> docker run llc -> docker run as -> docker run clang (link)
# Optional fallback (if --allow-clang-ir): use docker run clang -x ir when llc/as are unavailable

# Docker image name
DOCKER_IMG="cc1"

# Function to run command in container
run_in_container() {
    local cmd="$1"
    shift
    docker run --rm -v "$(pwd)":/workspace -w /workspace "$DOCKER_IMG" "$cmd" "$@"
}

# Function to run command in container and capture stdout
run_in_container_capture() {
    local cmd="$1"
    shift
    docker run --rm -v "$(pwd)":/workspace -w /workspace "$DOCKER_IMG" "$cmd" "$@"
}

# Function to check if container exists and build it if needed
ensure_container() {
    if ! docker image inspect "$DOCKER_IMG" >/dev/null 2>&1; then
        echo "Building container image..." >&2
        docker build -t "$DOCKER_IMG" .
    fi
}

show_help() {
  cat <<EOF
fcc â€” Forty-two Compiler Collection driver (Containerized)

SYNOPSIS
  fcc [options] <infile.c|->

DESCRIPTION
  fcc is a containerized compiler driver that orchestrates the full toolchain:
    1) Preprocess:  docker run clang -E -std=c89 (C preprocessing)
    2) Compile:     docker run cc1 (C89 -> LLVM IR)  
    3) Lower:       docker run llc (LLVM IR -> assembly)
    4) Assemble:    docker run as  (assembly -> object)
    5) Link:        docker run clang -m32|-m64 (object -> executable)

  All external tools (clang, llc, as) are executed within the Docker container
  to ensure consistent toolchain behavior across different host systems.
  The default mode is to link and produce an executable. Use -c or -S to stop earlier,
  or -E to only preprocess.

OPTIONS
  -o <outfile>      Output file (default: a.out; for -c/-S defaults to <in>.o/.s; for -E, defaults to stdout). Use '-' for stdout.
  -m32|-m64         Target arch (default: -m32)
  -g                Enable debug info (passed to cc1)
  -std=<v>          Language standard for preprocessing (c89|c90|ansi; default: c89)
  -O <n>            Optimization level (forwarded to llc/clang as -O<n>)
  -ffreestanding    Provide minimal builtin/type/attribute defines to tolerate system headers (maps __builtin_va_list, strips __attribute__/__asm__ etc.)
  --use-cc1-pp      Use cc1 internal preprocessor instead of clang -E (fallback)
  
  Preprocessor options (forwarded to clang -E by default):
    -I <dir>        Add include path
    -isystem <dir>  Add system include path
    -include <hdr>  Force include header before processing
    -D <mac>=<v>    Define macro
    -U <mac>        Undefine macro
    -Wp,<opts>      Pass options to the preprocessor
    -M, -MM         Generate dependencies to stdout and exit
    -MD, -MMD       Generate dependencies side file during compilation
    -MF <file>      Dependency output file
    -MG, -MP        Treat missing headers as generated / add phony targets
    -MT <t>, -MQ <t>  Dependency target

  Compiler/Assembler/Linker passthrough:
    -Wc,<opts>      Pass comma-separated opts to cc1
    -Wa,<opts>      Pass comma-separated opts to as (and clang in IR fallback)
    -Wl,<opts>      Pass options to the linker
    -L <dir>        Add linker search path
    -l <lib>        Link with library
    -s              Strip symbols at link time
    -nostdlib       Do not use standard system startup or libraries
    -nostartfiles   Do not use standard system startup files
    -nodefaultlibs  Do not use standard system libraries
    -static         Link statically
    -pthread        Enable pthreads (linker flag)

  Modes:
    -c               Compile only (emit object)
    -S               Compile to assembly
    -E               Preprocess only

  Misc:
    -v               Verbose: print executed commands
    --allow-clang-ir Allow using clang to lower/assemble IR when llc/as are missing
    -h, --help       Show this help
    --               End of options

  Note: All c17 POSIX options implemented except -B -G -R (as specified in the subject).

OPERANDS
  <infile.c>        Input C source file. Use '-' to read from standard input.

STDIN
  Read when the operand is '-'. Forwarded to the preprocessor.

INPUT FILES
  C89 source code. Preprocessing is performed by clang -E -std=c89 by default unless --use-cc1-pp is specified.

STDOUT
  With -E and without -o, the preprocessed source is written to standard output.
  With -o - in -S/-c modes, assembly/object is written to standard output.

STDERR
  Diagnostics from fcc and underlying tools are written to standard error. With -v, invoked commands are echoed.

EXIT STATUS
  0 on success; non-zero on any error from the driver or underlying tools.
EOF
}

ARCH="-m32"
DEBUG=""
OPTIM=""
OUT="a.out"
INFILE=""
MODE="link"   # link|obj|asm|pp
PP_ARGS=()
LLC_ARGS=()
LD_ARGS=()
AS_ARGS=()
WA_CLANG_ARGS=()
CC1_ARGS=()
ALLOW_CLANG_IR=0
USE_INTERNAL_PP=0
STD="c89"
VERBOSE=0
FREESTANDING=0
# Optimization level (default none)
OPTIM=""
# Dependency-generation tracking
M_SEEN=0
MD_SEEN=0
# Track if -o was explicitly provided
OUT_SPECIFIED=0

# Ensure container is available
ensure_container

# Parse args
ARGS=($@)
idx=0
stop_opts=0
while [[ $idx -lt ${#ARGS[@]} ]]; do
  a="${ARGS[$idx]}"
  if [[ $stop_opts -eq 1 ]]; then
    if [[ -z "$INFILE" ]]; then INFILE="$a"; else echo "fcc: multiple input files not supported" >&2; exit 1; fi
    idx=$((idx+1)); continue
  fi
  case "$a" in
    -h|--help) show_help; exit 0;;
    --) stop_opts=1; idx=$((idx+1));;
    -m32|-m64) ARCH="$a"; idx=$((idx+1));;
    -g) DEBUG="-g"; idx=$((idx+1));;
    -O0|-O1|-O2|-O3|-Os|-Oz) OPTIM="$a"; idx=$((idx+1));;
    -v) VERBOSE=1; idx=$((idx+1));;
    -ffreestanding) FREESTANDING=1; idx=$((idx+1));;
        --use-cc1-pp) USE_INTERNAL_PP=1; idx=$((idx+1));;
    -o)
      if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -o needs an argument" >&2; exit 1; fi
      OUT_SPECIFIED=1
      OUT="${ARGS[$((idx+1))]}"; idx=$((idx+2));;
    -I*|-isystem*)
      if [[ "$a" =~ ^-I.+ ]]; then
        # -Ipath format
        PP_ARGS+=("$a"); idx=$((idx+1))
      elif [[ "$a" =~ ^-isystem.+ ]]; then
        # -isystempath format
        PP_ARGS+=("$a"); idx=$((idx+1))
      elif [[ "$a" == "-I" ]]; then
        # -I path format
        if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -I needs an argument" >&2; exit 1; fi
        PP_ARGS+=("-I" "${ARGS[$((idx+1))]}"); idx=$((idx+2))
      elif [[ "$a" == "-isystem" ]]; then
        # -isystem path format
        if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -isystem needs an argument" >&2; exit 1; fi
        PP_ARGS+=("-isystem" "${ARGS[$((idx+1))]}"); idx=$((idx+2))
      fi;;
    -include)
      if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -include needs an argument" >&2; exit 1; fi
      PP_ARGS+=("-include" "${ARGS[$((idx+1))]}"); idx=$((idx+2));;
    -D*|-U*)
      if [[ "$a" =~ ^-[DU].+ ]]; then
        # -DNAME=VALUE or -UNAME format
        PP_ARGS+=("$a"); idx=$((idx+1))
      else
        # -D NAME or -U NAME format
        if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: $a needs an argument" >&2; exit 1; fi
        PP_ARGS+=("$a" "${ARGS[$((idx+1))]}"); idx=$((idx+2))
      fi;;
    -Wp,*)
      PP_ARGS+=("$a"); idx=$((idx+1));;
    -Wc,*)
      wc_opts="${a#-Wc,}"; IFS=',' read -ra _wc <<< "$wc_opts"; CC1_ARGS+=("${_wc[@]}"); unset IFS; idx=$((idx+1));;
    -Wa,*)
      WA_CLANG_ARGS+=("$a"); wa_opts="${a#-Wa,}"; IFS=',' read -ra _wa <<< "$wa_opts"; AS_ARGS+=("${_wa[@]}"); unset IFS; idx=$((idx+1));;
    -M|-MM|-MD|-MMD|-MG|-MP)
      PP_ARGS+=("$a");
      [[ "$a" == "-M" || "$a" == "-MM" ]] && M_SEEN=1
      [[ "$a" == "-MD" || "$a" == "-MMD" ]] && MD_SEEN=1
      idx=$((idx+1));;
    -MF|-MT|-MQ)
      if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: $a needs an argument" >&2; exit 1; fi
      PP_ARGS+=("$a" "${ARGS[$((idx+1))]}"); idx=$((idx+2));;
    -MF*|-MT*|-MQ*)
      PP_ARGS+=("$a"); idx=$((idx+1));;
    -L)
      if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -L needs an argument" >&2; exit 1; fi
      LD_ARGS+=("-L" "${ARGS[$((idx+1))]}"); idx=$((idx+2));;
    -l)
      if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -l needs an argument" >&2; exit 1; fi
      LD_ARGS+=("-l" "${ARGS[$((idx+1))]}"); idx=$((idx+2));;
    -s)
      LD_ARGS+=("-s"); idx=$((idx+1));;
    -O)
      if [[ $((idx+1)) -ge ${#ARGS[@]} ]]; then echo "fcc: -O needs a level" >&2; exit 1; fi
      OPTIM="-O${ARGS[$((idx+1))]}"; idx=$((idx+2));;
    -std=*)
      STD="${a#-std=}"; idx=$((idx+1));;
    -c) MODE="obj"; idx=$((idx+1));;
    -S) MODE="asm"; idx=$((idx+1));;
    -E) MODE="pp"; idx=$((idx+1));;
    -nostdlib|-nodefaultlibs|-nostartfiles|-static|-pthread)
      LD_ARGS+=("$a"); idx=$((idx+1));;
    -Wl,*)
      LD_ARGS+=("$a"); idx=$((idx+1));;
    --allow-clang-ir) ALLOW_CLANG_IR=1; idx=$((idx+1));;
    -*) 
      if [[ "$a" == "-" ]]; then
        # stdin input file
        if [[ -z "$INFILE" ]]; then INFILE="$a"; else echo "fcc: multiple input files not supported" >&2; exit 1; fi
        idx=$((idx+1))
      else
        echo "fcc: unknown option: $a" >&2; exit 1
      fi;;
    *)
      if [[ -z "$INFILE" ]]; then INFILE="$a"; else echo "fcc: multiple input files not supported" >&2; exit 1; fi
      idx=$((idx+1));;
  esac
done

[[ -n "$INFILE" ]] || { echo "fcc: error: no input" >&2; exit 1; }

# Compute sensible default outputs if -o was not specified
if [[ $OUT_SPECIFIED -eq 0 ]]; then
  if [[ "$MODE" == "obj" ]]; then
    if [[ "$INFILE" == "-" ]]; then OUT="-"; else base="${INFILE##*/}"; base="${base%.*}"; OUT="${base}.o"; fi
  elif [[ "$MODE" == "asm" ]]; then
    if [[ "$INFILE" == "-" ]]; then OUT="-"; else base="${INFILE##*/}"; base="${base%.*}"; OUT="${base}.s"; fi
  elif [[ "$MODE" == "pp" ]]; then
    OUT="-"  # Default to stdout for preprocessing
  fi
fi

# Verbose tracing
if [[ $VERBOSE -eq 1 ]]; then set -x; fi

# Validate/normalize standard
case "$STD" in
  c89|c90|ansi) :;;
  *) echo "fcc: warning: unsupported -std=$STD; forcing -std=c89 for preprocessing" >&2; STD="c89";;
esac

# Always use nostdinc for C89 compliance and our minimal headers
PP_ARGS+=(
  "-nostdinc"
  "-I" "/workspace/tools/include"
  "-D" "__attribute__(...)="
  "-D" "__asm__(...)="
  "-D" "__inline__="
  "-D" "__inline="
  "-D" "__restrict__="
  "-D" "__restrict="
  "-D" "__extension__="
  "-D" "__volatile__="
)

# Inject additional freestanding-friendly defines if requested
if [[ $FREESTANDING -eq 1 ]]; then
  PP_ARGS+=(
    "-D" "__STDC_HOSTED__=0"
  )
else
  PP_ARGS+=(
    "-D" "__STDC_HOSTED__=1"
  )
fi

# If pure dependency generation requested (-M/-MM without -MD/-MMD), run it and exit
if [[ $M_SEEN -eq 1 && $MD_SEEN -eq 0 ]]; then
  pp_lang=()
  if [[ "$INFILE" == "-" ]]; then pp_lang=(-x c); fi
  run_in_container clang -E -std=$STD "${PP_ARGS[@]}" "${pp_lang[@]}" "$INFILE"
  exit 0
fi

# Choose cc1 binary path inside container
CC1_BIN="/usr/local/bin/cc1"

# Preprocess step (always before cc1)
if [[ "$MODE" == "pp" ]]; then
  # Preprocess-only mode (-E): output preprocessed source
  if [[ $USE_INTERNAL_PP -eq 1 ]]; then
    # Use cc1 internal preprocessor
    if [[ "$OUT" == "-" ]]; then
      run_in_container "$CC1_BIN" --preprocess-only "$INFILE"
    else
      run_in_container "$CC1_BIN" --preprocess-only "$INFILE" -o "$OUT"
    fi
  else
    # Use clang -E -std=c89 to preprocess (DEFAULT)
    pp_lang=()
    if [[ "$INFILE" == "-" ]]; then pp_lang=(-x c); fi
    if [[ "$OUT" == "-" ]]; then
      run_in_container clang -E -std=$STD "${PP_ARGS[@]}" "${pp_lang[@]}" "$INFILE"
    else
      run_in_container clang -E -std=$STD "${PP_ARGS[@]}" "${pp_lang[@]}" "$INFILE" -o "$OUT"
    fi
  fi
  exit 0
fi

TMPDIR=$(mktemp -d)
trap 'rm -rf "$TMPDIR"' EXIT

# Use relative paths for temp files to ensure they're in the workspace
CPP_OUT="./tmp_out.i"
IR_OUT="./tmp_out.ll"
IR_USE="./tmp_out_use.ll"
ASM_OUT="./tmp_out.s"
OBJ_OUT="./tmp_out.o"

# Cleanup function for temp files
cleanup_temp() {
    rm -f "$CPP_OUT" "$IR_OUT" "$IR_USE" "$ASM_OUT" "$OBJ_OUT"
}
trap cleanup_temp EXIT

# 0) Preprocess
# Preprocessing step - use clang -E by default as required by subject
# But allow cc1 internal preprocessor with --use-cc1-pp option
has_pp_options=0
for arg in "${PP_ARGS[@]}"; do
  if [[ "$arg" =~ ^-[IDU] ]] || [[ "$arg" == "-include" ]] || [[ "$arg" == "-isystem" ]]; then
    has_pp_options=1
    break
  fi
done

if [[ $USE_INTERNAL_PP -eq 1 ]]; then
  # Use cc1 internal preprocessor when explicitly requested
  if [[ "$INFILE" == "-" ]]; then
    cat > "./tmp_input.raw"
    run_in_container "$CC1_BIN" --preprocess-only "./tmp_input.raw" -o "$CPP_OUT"
    rm -f "./tmp_input.raw"
  else
    run_in_container "$CC1_BIN" --preprocess-only "$INFILE" -o "$CPP_OUT"
  fi
else
  # Use clang preprocessor (DEFAULT as per subject specification)
  pp_lang=()
  if [[ "$INFILE" == "-" ]]; then pp_lang=(-x c); fi
  run_in_container clang -E -P -std=$STD "${PP_ARGS[@]}" "${pp_lang[@]}" "$INFILE" -o "$CPP_OUT"
fi

# 1) C -> LLVM IR (cc1)
cc1_arch="$ARCH"
if [[ "$ARCH" == "-m32" ]]; then cc1_arch="-m32"; else cc1_arch="-m64"; fi
# Write IR to file instead of trying to capture stdout
if [[ -n "$DEBUG" ]]; then
  run_in_container "$CC1_BIN" $cc1_arch $DEBUG --debug-source-file "$INFILE" "${CC1_ARGS[@]}" "$CPP_OUT" -o "$IR_OUT"
else
  run_in_container "$CC1_BIN" $cc1_arch $DEBUG "${CC1_ARGS[@]}" "$CPP_OUT" -o "$IR_OUT"
fi

# Strip any datalayout to avoid alignment issues across LLVM/targets
if grep -q "^target datalayout" "$IR_OUT"; then
  sed '/^target datalayout/d' "$IR_OUT" > "$IR_USE"
else
  cp "$IR_OUT" "$IR_USE"
fi

# Tool availability - all tools are available in container
HAS_LLC=1
HAS_AS=1

# 2) Lower IR to assembly or object
if [[ "$MODE" == "asm" ]]; then
  # Add optimization flag if specified (don't pass -g to llc)
  if [[ -n "$OPTIM" ]]; then LLC_ARGS+=("$OPTIM"); fi
  if [[ $HAS_LLC -eq 1 ]]; then
    run_in_container llc "${LLC_ARGS[@]}" "$IR_USE" -o "$ASM_OUT"
  elif [[ $ALLOW_CLANG_IR -eq 1 ]]; then
    # Use clang to produce assembly directly from IR
    run_in_container clang $ARCH $DEBUG "${LLC_ARGS[@]}" "${WA_CLANG_ARGS[@]}" -S -x ir "$IR_USE" -o "$ASM_OUT"
  else
    echo "fcc: error: llc not found. Install LLVM (llc) or pass --allow-clang-ir" >&2; exit 1
  fi
else
  # Add optimization flag if specified (don't pass -g to llc)  
  if [[ -n "$OPTIM" ]]; then LLC_ARGS+=("$OPTIM"); fi
  if [[ $HAS_LLC -eq 1 && $HAS_AS -eq 1 ]]; then
    # LLVM IR -> ASM via llc
    run_in_container llc "${LLC_ARGS[@]}" "$IR_USE" -o "$ASM_OUT"
    # ASM -> OBJ via as (as doesn't support -g in this context)
    if [[ "$ARCH" == "-m32" ]]; then
      run_in_container as --32 "${AS_ARGS[@]}" "$ASM_OUT" -o "$OBJ_OUT"
    else
      run_in_container as "${AS_ARGS[@]}" "$ASM_OUT" -o "$OBJ_OUT"
    fi
  elif [[ $ALLOW_CLANG_IR -eq 1 ]]; then
    # Compile IR to object directly with clang
    run_in_container clang $ARCH $DEBUG "${LLC_ARGS[@]}" "${WA_CLANG_ARGS[@]}" -c -x ir "$IR_USE" -o "$OBJ_OUT"
  else
    missing=()
    [[ $HAS_LLC -eq 1 ]] || missing+=("llc")
    [[ $HAS_AS  -eq 1 ]] || missing+=("as")
    echo "fcc: error: missing tool(s): ${missing[*]}. Install them or pass --allow-clang-ir" >&2; exit 1
  fi
fi

# 3) Link or emit final output
case "$MODE" in
  obj)
    if [[ "$OUT" == "-" ]]; then cat "$OBJ_OUT"; else mv "$OBJ_OUT" "$OUT"; fi;;
  asm)
    if [[ "$OUT" == "-" ]]; then cat "$ASM_OUT"; else mv "$ASM_OUT" "$OUT"; fi;;
  link)
    # Add optimization flag to linker if specified
    LINK_OPT=""
    if [[ -n "$OPTIM" ]]; then
      case "$OPTIM" in
        -O0) ;; # No optimization for linking
        -O1|-O2|-O3|-Os|-Oz) LINK_OPT="$OPTIM" ;;
      esac
    fi
    
    if [[ "$ARCH" == "-m32" ]]; then
      run_in_container clang -m32 -no-pie $DEBUG $LINK_OPT "${LD_ARGS[@]}" "$OBJ_OUT" -o "$OUT"
    else
      run_in_container clang -m64 $DEBUG $LINK_OPT "${LD_ARGS[@]}" "$OBJ_OUT" -o "$OUT"
    fi;;
  *) echo "fcc: internal error (mode)" >&2; exit 1;;
esac
